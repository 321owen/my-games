<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Archer Merge Fight</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Arial Rounded MT Bold', sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; }
        
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%;
            pointer-events: none;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border: 4px solid #2c3e50;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 6px 0 #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #merge-ui {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 110;
        }
        .controls-row { display: flex; gap: 20px; }
        .btn-cartoon {
            background: #f1c40f;
            border: 4px solid #2c3e50;
            padding: 15px 30px;
            border-radius: 20px;
            font-weight: 900;
            font-size: 1.2rem;
            box-shadow: 0 8px 0 #b8860b, 0 8px 0 4px #2c3e50;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.1s;
        }
        .btn-cartoon:active { transform: translateY(4px); box-shadow: 0 4px 0 #b8860b, 0 4px 0 4px #2c3e50; }
        .btn-battle { background: #e74c3c; color: white; box-shadow: 0 8px 0 #c0392b, 0 8px 0 4px #2c3e50; }
        
        .hidden { display: none !important; }
        #three-container { position: absolute; inset: 0; }
        
        .hint-text { color: #2c3e50; font-weight: 900; background: rgba(255,255,255,0.7); padding: 5px 15px; border-radius: 10px; }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-layer">
        <div class="stat-card text-2xl font-black text-blue-600">ðŸ’° <span id="gold-display">50</span></div>
        <div class="stat-card text-2xl font-black text-red-600">WAVE <span id="wave-display">1</span></div>
    </div>

    <div id="three-container"></div>
    <canvas id="gameCanvas" class="hidden"></canvas>

    <div id="merge-ui">
        <div class="hint-text">Drag back and release to unleash a volley!</div>
        <div class="controls-row">
            <button id="buy-btn" class="btn-cartoon">HIRE DEFENDER (<span id="cost-display">10</span>)</button>
            <button id="start-btn" class="btn-cartoon btn-battle">DEFEND!</button>
        </div>
    </div>
</div>

<script>
    // --- GAME STATE ---
    let state = 'MERGE';
    let gold = 50;
    let wave = 1;
    let archerCost = 10;
    let grid = Array(16).fill(null);
    grid[5] = { level: 1 };
    let screenShake = 0;

    const ARCHER_STYLES = {
        1: { color: 0x3498db, hex: '#3498db', scale: 0.85 },
        2: { color: 0x27ae60, hex: '#27ae60', scale: 0.95 },
        3: { color: 0xd35400, hex: '#d35400', scale: 1.1 },
        4: { color: 0x8e44ad, hex: '#8e44ad', scale: 1.25 },
        5: { color: 0xf1c40f, hex: '#f1c40f', scale: 1.45 }
    };

    function getArcherStyle(level) {
        return ARCHER_STYLES[level] || ARCHER_STYLES[5];
    }

    // --- THREE.JS (MERGE VIEW) ---
    const tContainer = document.getElementById('three-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 16, 16);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    tContainer.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(10, 20, 10);
    sun.castShadow = true;
    scene.add(sun);

    const castleGroup = new THREE.Group();
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x7f8c8d });
    const base = new THREE.Mesh(new THREE.BoxGeometry(10, 5, 10), baseMat);
    base.position.y = -2.5;
    castleGroup.add(base);

    const tiles = [];
    for (let i = 0; i < 16; i++) {
        const x = (i % 4) - 1.5;
        const z = Math.floor(i / 4) - 1.5;
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.1, 1.9), new THREE.MeshStandardMaterial({ color: 0xbdc3c7, transparent: true, opacity: 0.2 }));
        mesh.position.set(x * 2.1, 0.1, z * 2.1);
        mesh.userData.index = i;
        castleGroup.add(mesh);
        tiles.push(mesh);
    }
    scene.add(castleGroup);

    const archerMeshes = new Array(16).fill(null);

    function create3DArcher(level) {
        const style = getArcherStyle(level);
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: style.color }));
        body.position.y = 0.5;
        group.add(body);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshStandardMaterial({ color: 0xf3e5ab }));
        head.position.y = 1.2;
        group.add(head);
        group.scale.set(style.scale, style.scale, style.scale);
        return group;
    }

    function updateThreeView() {
        tiles.forEach((tile, i) => {
            if (archerMeshes[i]) { scene.remove(archerMeshes[i]); archerMeshes[i] = null; }
            if (grid[i]) {
                const archer = create3DArcher(grid[i].level);
                archer.position.copy(tile.position);
                scene.add(archer);
                archerMeshes[i] = archer;
            }
        });
    }

    // --- Interaction ---
    const raycaster = new THREE.Raycaster();
    const mouseVec = new THREE.Vector2();
    let selectedIdx = null;

    window.addEventListener('mousedown', (e) => {
        if (state !== 'MERGE') return;
        mouseVec.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouseVec.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouseVec, camera);
        const intersects = raycaster.intersectObjects(tiles);
        if (intersects.length > 0) {
            const idx = intersects[0].object.userData.index;
            if (grid[idx]) {
                selectedIdx = idx;
                tiles[idx].material.opacity = 0.8;
            }
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (state !== 'MERGE' || selectedIdx === null) return;
        mouseVec.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouseVec.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouseVec, camera);
        const intersects = raycaster.intersectObjects(tiles);
        if (intersects.length > 0) {
            const targetIdx = intersects[0].object.userData.index;
            if (targetIdx !== selectedIdx) {
                const source = grid[selectedIdx], target = grid[targetIdx];
                if (!target) { grid[targetIdx] = source; grid[selectedIdx] = null; }
                else if (target.level === source.level) { grid[targetIdx] = { level: source.level + 1 }; grid[selectedIdx] = null; gold += 10; }
            }
        }
        tiles[selectedIdx].material.opacity = 0.2;
        selectedIdx = null;
        updateThreeView(); updateUI();
    });

    function animateThree() {
        if (state === 'MERGE') {
            requestAnimationFrame(animateThree);
            renderer.render(scene, camera);
        }
    }

    // --- BATTLE LOGIC ---
    const canvas2d = document.getElementById('gameCanvas');
    const ctx = canvas2d.getContext('2d');
    let playerUnits = [], enemyUnits = [], arrows = [], particles = [];
    let isDragging = false, dragStart = {x:0, y:0}, dragEnd = {x:0, y:0};

    function startBattle() {
        state = 'BATTLE';
        document.getElementById('merge-ui').classList.add('hidden');
        tContainer.classList.add('hidden');
        canvas2d.classList.remove('hidden');
        resize();
        arrows = []; particles = [];
        playerUnits = []; enemyUnits = [];

        const activeArchers = grid.filter(g => g !== null);
        activeArchers.forEach((arch, i) => {
            const spacing = (canvas2d.height - 150) / (activeArchers.length + 1);
            playerUnits.push({ 
                x: 60, y: 75 + spacing * (i + 1), 
                level: arch.level, style: getArcherStyle(arch.level),
                hp: 40 + arch.level * 20, maxHp: 40 + arch.level * 20, 
                targetY: 75 + spacing * (i + 1), yOffset: 0
            });
        });

        const eCount = 2 + Math.floor(wave / 2);
        for (let i = 0; i < eCount; i++) {
            const spacing = (canvas2d.height - 150) / (eCount + 1);
            enemyUnits.push({ 
                x: canvas2d.width - 60, y: 75 + spacing * (i + 1), 
                level: Math.max(1, Math.floor(wave/3) + 1), 
                hp: 25 + wave * 15, maxHp: 25 + wave * 15, 
                lastShot: Date.now() + Math.random() * 2000,
                yOffset: 0
            });
        }
        requestAnimationFrame(battleLoop);
    }

    function createParticles(x, y, color) {
        for(let i=0; i<8; i++) {
            particles.push({
                x, y, color,
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                life: 1.0
            });
        }
    }

    function battleLoop() {
        if (state !== 'BATTLE') return;
        
        // Background and Shake
        ctx.save();
        if (screenShake > 0) {
            ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
            screenShake *= 0.9;
        }
        ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);

        // Castles
        ctx.fillStyle = '#636e72';
        ctx.fillRect(0, 0, 80, canvas2d.height);
        ctx.fillRect(canvas2d.width - 80, 0, 80, canvas2d.height);
        ctx.fillStyle = '#2d3436';
        for(let y=10; y<canvas2d.height; y+=60) {
            ctx.fillRect(70, y, 20, 30);
            ctx.fillRect(canvas2d.width - 90, y, 20, 30);
        }

        // Projectiles
        arrows = arrows.filter(a => {
            a.vx *= 0.998; a.vy += 0.35;
            a.x += a.vx; a.y += a.vy;
            
            ctx.save(); ctx.translate(a.x, a.y); ctx.rotate(Math.atan2(a.vy, a.vx));
            ctx.fillStyle = a.color;
            ctx.fillRect(-12, -2, 24, 4);
            ctx.restore();

            const targets = a.isEnemy ? playerUnits : enemyUnits;
            let hit = false;
            targets.forEach(t => {
                const dist = Math.sqrt((a.x-t.x)**2 + (a.y-(t.y+t.yOffset))**2);
                if (dist < 30) { 
                    t.hp -= a.dmg; 
                    hit = true; 
                    t.yOffset += a.vy * 0.5; // Visual knockback
                    createParticles(a.x, a.y, a.color);
                    screenShake = 5;
                }
            });
            return !hit && a.y < canvas2d.height && a.x > 0 && a.x < canvas2d.width;
        });

        // Particles
        particles = particles.filter(p => {
            p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= 0.02;
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 4, 4);
            ctx.globalAlpha = 1.0;
            return p.life > 0;
        });

        // Enemy AI - Rapid Vibe
        enemyUnits.forEach(e => {
            e.yOffset *= 0.9; // Recover from knockback
            if (Date.now() - e.lastShot > (3000 / (1 + wave * 0.1))) {
                const target = playerUnits[Math.floor(Math.random()*playerUnits.length)];
                if (target) {
                    const dx = target.x - e.x, dy = (target.y + target.yOffset) - (e.y + e.yOffset);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    arrows.push({
                        x: e.x, y: e.y + e.yOffset, vx: (dx/dist)*22, vy: -12 + (Math.random()-0.5)*10, 
                        dmg: 8 + wave * 2, isEnemy: true, color: '#ff4757'
                    });
                    e.lastShot = Date.now();
                }
            }
        });

        // Draw Units
        [...playerUnits, ...enemyUnits].forEach(u => {
            u.yOffset *= 0.9;
            const color = u.style ? u.style.hex : '#ff4757';
            const s = u.style ? u.style.scale : 0.9;
            const curY = u.y + u.yOffset;
            
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.roundRect(u.x-18*s, curY-18*s, 36*s, 36*s, 8); ctx.fill();
            ctx.fillStyle = '#f3e5ab';
            ctx.beginPath(); ctx.arc(u.x, curY-20*s, 12*s, 0, Math.PI*2); ctx.fill();
            
            // HP Bar
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(u.x-25, curY-50, 50, 6);
            ctx.fillStyle = u.isEnemy ? '#ff4757' : '#2ecc71'; 
            ctx.fillRect(u.x-25, curY-50, 50*(u.hp/u.maxHp), 6);
        });

        // Drag Indicator
        if (isDragging) {
            const dx = dragStart.x - dragEnd.x, dy = dragStart.y - dragEnd.y;
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.setLineDash([10, 5]);
            ctx.beginPath(); ctx.moveTo(dragStart.x, dragStart.y); 
            ctx.lineTo(dragStart.x + dx, dragStart.y + dy); ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.restore();

        playerUnits = playerUnits.filter(u => u.hp > 0);
        enemyUnits = enemyUnits.filter(u => u.hp > 0);

        if (enemyUnits.length === 0) { state = 'MERGE'; gold += 50 + wave*15; wave++; endBattle(); }
        else if (playerUnits.length === 0) { state = 'MERGE'; wave = 1; gold = 50; grid = Array(16).fill(null); grid[5]={level:1}; endBattle(); }
        else requestAnimationFrame(battleLoop);
    }

    function endBattle() {
        canvas2d.classList.add('hidden');
        tContainer.classList.remove('hidden');
        document.getElementById('merge-ui').classList.remove('hidden');
        updateThreeView(); updateUI(); animateThree();
    }

    function updateUI() {
        document.getElementById('gold-display').innerText = gold;
        document.getElementById('wave-display').innerText = wave;
        document.getElementById('cost-display').innerText = archerCost;
    }

    document.getElementById('buy-btn').onclick = () => {
        if (gold >= archerCost) {
            const empty = grid.findIndex(g => g === null);
            if (empty !== -1) {
                gold -= archerCost; grid[empty] = { level: 1 };
                archerCost = Math.floor(archerCost * 1.3);
                updateThreeView(); updateUI();
            }
        }
    };
    document.getElementById('start-btn').onclick = startBattle;

    function resize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        canvas2d.width = window.innerWidth; canvas2d.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);

    canvas2d.addEventListener('mousedown', e => { 
        if(state === 'BATTLE') { isDragging = true; dragStart = {x:e.clientX, y:e.clientY}; dragEnd = dragStart; }
    });
    window.addEventListener('mousemove', e => { if(isDragging) dragEnd = {x:e.clientX, y:e.clientY}; });
    window.addEventListener('mouseup', e => {
        if(!isDragging) return;
        isDragging = false;
        const dx = dragStart.x - e.clientX, dy = dragStart.y - e.clientY;
        const power = Math.sqrt(dx*dx+dy*dy);
        if (power > 25) {
            playerUnits.forEach(u => {
                // Crazy Volley Mechanics
                const spread = (Math.random()-0.5) * 5;
                arrows.push({
                    x: u.x, y: u.y + u.yOffset, 
                    vx: dx * 0.22, 
                    vy: dy * 0.22 + spread, 
                    dmg: u.level * 15, isEnemy: false, color: u.style.hex
                });
            });
            screenShake = 3;
        }
    });

    updateThreeView(); updateUI(); animateThree();
</script>
</body>
</html>
